import shortid from 'shortid'

export const subscribe = async ({ db, TableName, apiId, connectionId, userId, sessionId, id, list }) => {
	// TODO make sure the user has access to all subscribed paths

	const writableItems = list.map(item => {
		const subscriptionId = shortid.generate()

		return {
			subscriptionId,
			items: [
				// Used to get a list of all connections subscribed to
				// a collection, by querying for pk=coll:$COLLECTION
				// You will need to get the full object to have enough
				// information to publish a message to the client.
				{
					pk: {
						S: `coll:${item.path}`
					},
					sk: {
						S: `conn:${connectionId}`
					},
					gid: {
						S: `ws:${userId}:sess:${sessionId}`
					},
					api: {
						S: apiId
					}
					subid: {
						S: subscriptionId
					},
					subtype: {
						S: item.type
					}
				},
				// Used to do a lookup when a connection unsubscribes,
				// which uses a subscription identifier. On an unsubscribe
				// you would do a lookup of this object and use that to
				// do a lookup of the previous ^ object for deletion.
				{
					pk: {
						S: `conn:${connectionId}`
					},
					sk: {
						S: `subid:${subscriptionId}`
					},
					gid: {
						S: `ws:${userId}:sess:${sessionId}`
					},
					coll: {
						S: item.path
					}
				}
			]
		}
	})

	const result = await db.batchWriteItem({
		RequestItems: {
			[TableName]: writableItems
				.map(item => item.items)
				.flat()
				.map(Item => ({
					PutRequest: { Item }
				}))
		},
		ReturnConsumedCapacity: 'TOTAL',
		ReturnItemCollectionMetrics: 'SIZE'
	}).promise()

	return {
		result,
		response: [
			id,
			'200',
			'Subscribed',
			writableItems
				.map(item => item.subscriptionId)
		]
	}
}
